# UI
# ─────────────────────────
# relative line numbers
add-highlighter global/ number-lines -relative -hlcursor -cursor-separator *
add-highlighter global/ wrap -word
add-highlighter global/ show-matching
# Highlight trailing whitespace
add-highlighter global/ regex \h+$ 0:Error
add-highlighter global/ regex \t 0:Error
add-highlighter global/ regex //\h*(TODO:)[^\n]* 0:cyan 1:yellow,red
add-highlighter global/ dynregex '%reg{/}' 0:+i

# Options
# ─────────────────────────
set-option global tabstop 4
set-option global grepcmd 'rg --column'

# Hooks
# ─────────────────────────
hook global WinSetOption filetype=kotlin %[
    set-option window makecmd 'just build'
    set-option window lintcmd 'just build check'
]

# Commands
# ─────────────────────────
define-command mkdir -docstring "" -params .. %{ echo %sh{ mkdir -pv ${@-$(dirname $kak_buffile)} } }
# Shortcut to quickly exit the editor
define-command -docstring "save and quit" x "write-all; quit"
define-command delete-buffers-match -docstring "Delete all buffers matching giving pattern" -params 1.. %{ evaluate-commands %sh{
    pattern=$1
    eval "set -- $kak_quoted_buflist"
    for buf in "$@"; do
        printf "%s\n" "$buf"
    done | rg $pattern - | while read f; do
        printf "delete-buffer '$f'\n"
    done
}}
complete-command delete-buffers-match buffer

define-command kill-fifo-process -docstring "Kill commands run within the fifo command" -params 0.. %{nop %sh{
    lsof -c '^kak' | rg "kak-fifo" | rg "${@-.}" | awk '{print $2}' | uniq | xargs kill -9
}}
define-command just -docstring "run just command" -params 1.. %{
    fifo just --unstable "%arg{@}"
}
complete-command just shell-script-candidates %{ for receipt in $(just --unstable --summary); do echo "$receipt"; done }

define-command edit-file -docstring "Open all files matching giving pattern" -params .. %{
    edit %arg{@}
}
complete-command edit-file shell-script-candidates %{ fd -tf . . }
define-command edit-match -docstring "Open all files matching giving pattern" -params .. %{
    for-each-line edit fd -p %arg{@}
}
complete-command edit-match shell-script-candidates %{ fd -tf . . }
define-command window-edit-match -docstring "Open all files matching giving pattern in windows" -params .. %{
    for-each-line 'new edit' fd -p %arg{@}
}
complete-command window-edit-match shell-script-candidates %{ fd -tf . . }

define-command find -docstring "find files" -params .. %{
    run-in-shell 'for-each-line edit cat' fd -tf %arg{@} | sk -m
}
complete-command find shell-script-candidates %{ fd -tf . . }
define-command window-find -docstring "find files in other windows" -params .. %{
    run-in-shell 'for-each-line "new edit" cat' fd -tf %arg{@} | sk -m
}
complete-command window-find shell-script-candidates %{ fd -tf . . }

# Keys
# ─────────────────────────
map global insert <tab> '<a-;><gt>'
map global insert <s-tab> '<a-;><lt>'
map global goto n '<esc>:bn<ret>' -docstring 'next buffer'
map global goto p '<esc>:bp<ret>' -docstring 'previous buffer'
map global goto x '<esc><a-|>open `cat`<ret>' -docstring "Open selection with external program"
map global user q %{:x<ret>} -docstring "Save and quit"
map global user c %{:comment-line<ret>} -docstring "Comment line"
map global user b %{:buffer } -docstring "Buffer"
map global user d %{:delete-buffer<ret>} -docstring "Delete buffer"
map global user D %{:delete-buffers-match } -docstring "Delete buffers"
map global user f %{:edit-file } -docstring "Find file"
map global user F %{:edit-match } -docstring "Find files"
map global user w %{:window-find<ret>} -docstring "Open files in windows"
map global user W %{:window-edit-match } -docstring "Find files in windows"
map global user / %{:grep } -docstring "Grep"
map global user < %{:fifo } -docstring "Fifo"
map global user : %{:suspend-and-resume nop } -docstring "Run in terminal"
map global user s %{:new edit!<ret>} -docstring "Split window"
map global user j %{:just } -docstring "Run just command"

# System clipboard handling
# ─────────────────────────

evaluate-commands %sh{
    if [ -n "$SSH_TTY" ]; then
        copy='printf "\033]52;;%s\033\\" $(base64 | tr -d "\n") > $( [ -n "$client_client_pid" ] && echo /proc/$client_client_pid/fd/0 || echo /dev/tty )'
        paste='printf "paste unsupported through ssh"'
        backend="OSC 52"
    else
        case $(uname) in
            Linux)
                if [ -n "$WAYLAND_DISPLAY" ]; then
                    copy="wl-copy -p"; paste="wl-paste -p"; backend=Wayland
                else
                    copy="xclip -i"; paste="xclip -o"; backend=X11
                fi
                ;;
            Darwin)  copy="pbcopy"; paste="pbpaste"; backend=OSX ;;
        esac
    fi
    printf "map global user -docstring 'paste (after) from clipboard' p '<a-!>%s<ret>'\n" "$paste"
    printf "map global user -docstring 'paste (before) from clipboard' P '!%s<ret>'\n" "$paste"
    printf "map global user -docstring 'yank to primary' y '<a-|>%s<ret>:echo -markup %%{{Information}copied selection to %s primary}<ret>'\n" "$copy" "$backend"
    printf "map global user -docstring 'yank to clipboard' Y '<a-|>%s<ret>:echo -markup %%{{Information}copied selection to %s clipboard}<ret>'\n" "$copy -selection clipboard" "$backend"
    printf "map global user -docstring 'replace from clipboard' R '|%s<ret>'\n" "$paste"
    printf "define-command -override echo-to-clipboard -params .. %%{ echo -to-shell-script '%s' -- %%arg{@} }" "$copy"
}

# Helper commands
# ─────────────────────────
define-command -params .. fifo %{ evaluate-commands %sh{
    output=$(mktemp -d "${TMPDIR:-/tmp}"/kak-fifo.XXXXXXXX)/fifo
    mkfifo ${output}
    ( eval "$@" > ${output} 2>&1 & ) > /dev/null 2>&1 < /dev/null
    printf %s\\n "evaluate-commands -try-client '$client_opt_toolsclient' %{
        edit! -fifo ${output} '*fifo*'
        hook -always -once buffer BufCloseFifo .* %{ nop %sh{ rm -rf $(dirname ${output}) } }
    }"
}}
complete-command fifo shell

define-command for-each-line \
    -docstring "for-each-line <command> <cli command>: run command with the value of each line ouput from the cli command" \
    -params 2.. \
    %{ evaluate-commands %sh{
    ${@:2} | while read f; do
        printf "$1 $f\n"
    done
}}

define-command suspend-and-resume \
    -params 2.. \
    -docstring 'suspend-and-resume <kak command after resume> <cli commands>: backgrounds current kakoune client and runs specified cli commands.  Upon exit of command the optional kak command is executed.' \
    %{ evaluate-commands %sh{

    # Note we are adding '&& fg' which resumes the kakoune client process after the cli command exits
    cli_cmd="${@:2} && fg"
    post_resume_cmd="$1"

    # automation is different platform to platform
    platform=$(uname -s)
    case $platform in
        Darwin)
            automate_cmd="sleep 0.01; osascript -e 'tell application \"System Events\" to keystroke \"$cli_cmd\" & return ' || printf '$cli_cmd' | pbcopy"
            kill_cmd="/bin/kill"
            break
            ;;
        Linux)
            automate_cmd="sleep 0.2; xdotool type '$cli_cmd'; xdotool key Return"
            kill_cmd="/usr/bin/kill"
            break
            ;;
    esac

    # Uses platforms automation to schedule the typing of our cli command
    nohup sh -c "$automate_cmd"  > /dev/null 2>&1 &
    # Send kakoune client to the background
    $kill_cmd -SIGTSTP $kak_client_pid

    # ...At this point the kakoune client is paused until the " && fg " gets run in the $automate_cmd

    # Upon resume, run the kak command is specified
    if [ ! -z "$post_resume_cmd" ]; then
        echo "$post_resume_cmd"
    fi
}}
complete-command suspend-and-resume shell

define-command run-in-shell \
    -docstring 'run-in-shell <kak command after resume> <cli command>: backgrounds current kakoune client and runs specified cli command. the cli command will ouput will pass to the kak command with a buffer file.' \
    -params 2.. %{ evaluate-commands %sh{
    file="/tmp/kak-fifo-$kak_client_pid"
    postcmd="${1}"
    printf "suspend-and-resume '$postcmd $file' ${@:2} > $file"
}}
complete-command run-in-shell shell
