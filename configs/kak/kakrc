# UI
# ─────────────────────────
# relative line numbers
add-highlighter global/ number-lines -relative -hlcursor
add-highlighter global/ wrap -word
add-highlighter global/ show-matching
# Highlight trailing whitespace
add-highlighter global/ regex \h+$ 0:Error
add-highlighter global/ regex \t 0:Error
add-highlighter global/ regex //\h*(TODO:)[^\n]* 0:cyan 1:yellow,red
add-highlighter global/ dynregex '%reg{/}' 0:+i

# Options
# ─────────────────────────
set-option global tabstop 4
set-option global grepcmd 'rg --vimgrep'
set-option global toolsclient 'client1'
set-option global ctagscmd 'ctags -R --fields=+S --exclude=.git --exclude=build'

# Keys
# ─────────────────────────
map global normal '#' :comment-line<ret>
map global normal <c-a> %{:expr +<ret>} -docstring "Increment by given count"
map global normal <c-x> %{:expr -<ret>} -docstring "Descrement by given count"
map global insert <tab> '<c-n>'
map global prompt <a-n> '<tab>'
map global prompt <a-p> '<s-tab>'
map global prompt <a-.> '%sh{dirname "$kak_reg_percent"}<a-!>/' -docstring 'Expand to the buffer directory'
map global goto n '<esc>:bn<ret>' -docstring 'next buffer'
map global goto p '<esc>:bp<ret>' -docstring 'previous buffer'
map global goto x '<esc><a-|>open `cat`<ret>' -docstring "Open selection with external program"
map global user q %{:write-all-quit<ret>} -docstring "Save and quit"
map global user b %{:buffer } -docstring "Buffer"
map global user d %{:delete-buffer<ret>} -docstring "Delete buffer"
map global user D %{:delete-buffers-match } -docstring "Delete buffers"
map global user f %{:find<ret>} -docstring "Find a file"
map global user / %{:grep } -docstring "Grep"
map global user s %{:ctags-search } -docstring "Search symbol"
map global user : %{:sh } -docstring "Run a shell cmd"
map global user m %{:make<ret>} -docstring "Run make"
map global user i %{:info %sh{ }<left><left> } -docstring "Show a shell cmd output"
map global user l %{:pueue status ; prompt -init '-f ' 'task ids:' 'sh pueue log %val{text}'<ret>} -docstring "Task log"
map global user j %{:just } -docstring "Run just command"

# Hooks
# ─────────────────────────
hook global -always -once BufOpenFifo '\*grep\*' %{
    map global goto / '<esc>:grep-next-match<ret>' -docstring "Go to grep next match"
    map global goto ? '<esc>:grep-next-match<ret>' -docstring "Go to grep previous match"
}
hook global -always BufOpenFifo '\*make\*' %{
    map buffer normal <minus> ': make-next-error<ret>'
}
hook global WinSetOption filetype=zig %{
    set-option buffer makecmd 'zig build'
    set-option buffer formatcmd 'zig fmt --stdin'
    set-option buffer lintcmd 'zig fmt --check'
}
hook global WinSetOption filetype=kotlin %{
    set-option buffer makecmd 'abt -s @ build'
    set-option buffer formatcmd 'abt -s @ spotlessApply'
    set-option buffer lintcmd 'ktlint'
}
hook global ModuleLoaded wezterm %{
}

# Commands
# ─────────────────────────
define-command mkdir -docstring "" -params .. %{ echo %sh{ mkdir -pv ${@-$(dirname $kak_buffile)} } }
complete-command mkdir file
define-command delete-buffers-match -docstring "Delete all buffers matching giving pattern" -params 1 %{
    evaluate-commands -buffer %sh{
        pattern="$1"; eval set -- "$kak_quoted_buflist"
        bufs=$(for buf in "$@"; do printf "%s\n" "$buf"; done | grep "$pattern" - | tr '\n' ',')
        printf %s "${bufs%,}"
    } delete-buffer
}
complete-command delete-buffers-match buffer

define-command just -docstring "run just command" -params 1.. %{
    pueue-add just "%arg{@}"
}
complete-command just shell-script-candidates %{
    if [ $kak_token_to_complete -eq 0 ]; then
        for receipt in $(just --summary); do echo "$receipt"; done
    fi
}

define-command find -docstring "Find a file to open" -params .. %{
    suspend-and-resume \
      %exp{ fd -tf %arg{@} | sk -m --bind 'alt-a:select-all,alt-d:deselect-all' > /tmp/kak-find-%val{client_pid} } \
      "for-each-line edit /tmp/kak-find-%val{client_pid}"
}
complete-command find file

define-command -params 1.. -docstring "run a shell command" sh %{
    set-option buffer=*debug* makecmd "zsh -c '%arg{@}'"
    evaluate-commands -buffer *debug* make
    evaluate-commands -try-client "%opt{toolsclient}" buffer *make*
}
complete-command sh shell

define-command -params 1.. -docstring "find files" grep-file %{
    set-option buffer=*debug* grepcmd "fd -tf"
    evaluate-commands -buffer *debug* grep %arg{@} -x echo {}:1:0
    evaluate-commands -try-client "%opt{toolsclient}" buffer *grep*
}

define-command -params 1.. -docstring "run pueue commands" pueue %{ info %sh{ pueue $@ }}
complete-command pueue shell-script-candidates %{
    if [ $kak_token_to_complete -eq 0 ]; then
        printf "add\nremove\nrestart\nkill\nstatus\nlog\nclean\nreset\nsend\nparallel\n"
    fi
}
define-command -params 1.. -docstring "add a task to pueue" pueue-add %{ pueue add -- %arg{@} }
complete-command pueue-add shell

define-command -params 1..2 -docstring "expr <operator> [number]" expr %{ execute-keys %sh{
    if [ $kak_count = 0 ]; then kak_count=1; fi
    count=${2-$kak_count}
    printf '|expr `cat` %s %s<ret>' "$1" "${count-1}"
}}

def suspend-and-resume \
    -params 1..2 \
    -docstring 'suspend-and-resume <cli command> [<kak command after resume>]: backgrounds current kakoune client and runs specified cli command.  Upon exit of command the optional kak command is executed.' \
    %{ evaluate-commands %sh{

    # Note we are adding '&& fg' which resumes the kakoune client process after the cli command exits
    cli_cmd="$1 && fg"
    post_resume_cmd="$2"

    # automation is different platform to platform
    platform=$(uname -s)
    case $platform in
        Darwin)
            automate_cmd="sleep 0.01; osascript -e 'tell application \"System Events\" to keystroke \"$cli_cmd\" & return '"
            kill_cmd="/bin/kill"
            break
            ;;
        Linux)
            automate_cmd="sleep 0.2; xdotool type '$cli_cmd'; xdotool key Return"
            kill_cmd="/usr/bin/kill"
            break
            ;;
    esac

    # Uses platforms automation to schedule the typing of our cli command
    nohup sh -c "$automate_cmd"  > /dev/null 2>&1 &
    # Send kakoune client to the background
    $kill_cmd -SIGTSTP $kak_client_pid

    # ...At this point the kakoune client is paused until the " && fg " gets run in the $automate_cmd

    # Upon resume, run the kak command is specified
    if [ ! -z "$post_resume_cmd" ]; then
        echo "$post_resume_cmd"
    fi
}}
def for-each-line -docstring "for-each-line <command> <path to file>: run command with the value of each line in the file" -params 2 %{ evaluate-commands %sh{
    while read f; do
        printf "$1 $f\n"
    done < "$2"
}}
