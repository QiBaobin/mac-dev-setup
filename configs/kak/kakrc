# relative line numbers
add-highlighter global/ number-lines -relative -hlcursor
add-highlighter global/ wrap -word
add-highlighter global/ show-matching
# Highlight trailing whitespace
add-highlighter global/ regex \h+$ 0:Error

set-option global tabstop 4
set-option global grepcmd 'rg --column'

colorscheme palenight

hook global WinSetOption filetype=kotlin %[
    set-option window makecmd './abt -v build'
    set-option window lintcmd './abt -v build check'
]

define-command mkdir -docstring "" -params .. %{ echo %sh{ mkdir -pv ${@-$(dirname $kak_buffile)} } }
# Shortcut to quickly exit the editor
define-command -docstring "save and quit" x "write-all; quit"
define-command -params .. fifo %{ evaluate-commands %sh{
    output=$(mktemp -d "${TMPDIR:-/tmp}"/kak-fifo.XXXXXXXX)/fifo
    mkfifo ${output}
    ( eval "$@" > ${output} 2>&1 & ) > /dev/null 2>&1 < /dev/null
    printf %s\\n "evaluate-commands -try-client '$kak_opt_toolsclient' %{
        edit! -fifo ${output} *fifo*
        hook -always -once buffer BufCloseFifo .* %{ nop %sh{ rm -r $(dirname ${output}) } }
    }"
}}
complete-command fifo shell
define-command delete-buffers-match -docstring "Delete all buffers matching giving pattern" -params 1 %{ evaluate-commands %sh{
    pattern=$1
    eval "set -- $kak_buflist"
    for buf in "$@"; do
        printf "%s\n" "$buf"
    done | rg $pattern - | while read f; do
        printf "delete-buffer '$f'\n"
    done
}}
complete-command delete-buffers-match buffer
define-command edit-match -docstring "Open all files matching giving pattern" -params .. %{ evaluate-commands %sh{
    fd $@ | while read f; do
        printf "edit '$f'\n"
    done
}}
complete-command edit-match shell-script-candidates %{ fd -tf . . }
define-command window-edit-match -docstring "Open all files matching giving pattern in windows" -params .. %{ evaluate-commands %sh{
    fd $@ | while read f; do
        printf "window-edit '$f'\n"
    done
}}
complete-command window-edit-match shell-script-candidates %{ fd -tf . . }
define-command find -docstring "find files" -params .. %{
    terminal -c -d down fd -tf %arg{@} | sk -m | while read f\; do printf """eval -client %val{client} edit $f\n"""\; done | kak -p %val{session}
}
complete-command find shell-script-candidates %{ fd -tf . . }
define-command window-find -docstring "find files in other windows" -params .. %{
    terminal -c -d down fd -tf %arg{@} | sk -m | while read f\; do printf """eval -client %val{client} window-edit $f\n"""\; done | kak -p %val{session}
}
complete-command window-find shell-script-candidates %{ fd -tf . . }

map global user q %{:x<ret>} -docstring "Save and quit"
map global user c %{:comment-line<ret>} -docstring "Comment line"
map global user b %{:buffer } -docstring "Buffer"
map global user d %{:delete-buffer} -docstring "Delete buffer"
map global user D %{:delete-buffers-match } -docstring "Delete buffers"
map global goto n '<esc>:bn<ret>' -docstring 'next buffer'
map global goto p '<esc>:bp<ret>' -docstring 'previous buffer'
map global user f %{:find<ret>} -docstring "Open files"
map global user F %{:edit-match } -docstring "Find files"
map global user w %{:window-find<ret>} -docstring "Open files in windows"
map global user W %{:window-edit-match } -docstring "Find files in windows"
map global user / %{:grep } -docstring "Grep"
map global user < %{:fifo } -docstring "Shell"
map global user : %{:terminal } -docstring "Terminal"
map global user s %{:window-edit<ret>} -docstring "Split window"

# System clipboard handling
# ─────────────────────────

evaluate-commands %sh{
    if [ -n "$SSH_TTY" ]; then
        copy='printf "\033]52;;%s\033\\" $(base64 | tr -d "\n") > $( [ -n "$kak_client_pid" ] && echo /proc/$kak_client_pid/fd/0 || echo /dev/tty )'
        paste='printf "paste unsupported through ssh"'
        backend="OSC 52"
    else
        case $(uname) in
            Linux)
                if [ -n "$WAYLAND_DISPLAY" ]; then
                    copy="wl-copy -p"; paste="wl-paste -p"; backend=Wayland
                else
                    copy="xclip -i"; paste="xclip -o"; backend=X11
                fi
                ;;
            Darwin)  copy="pbcopy"; paste="pbpaste"; backend=OSX ;;
        esac
    fi
    printf "map global user -docstring 'paste (after) from clipboard' p '<a-!>%s<ret>'\n" "$paste"
    printf "map global user -docstring 'paste (before) from clipboard' P '!%s<ret>'\n" "$paste"
    printf "map global user -docstring 'yank to primary' y '<a-|>%s<ret>:echo -markup %%{{Information}copied selection to %s primary}<ret>'\n" "$copy" "$backend"
    printf "map global user -docstring 'yank to clipboard' Y '<a-|>%s<ret>:echo -markup %%{{Information}copied selection to %s clipboard}<ret>'\n" "$copy -selection clipboard" "$backend"
    printf "map global user -docstring 'replace from clipboard' R '|%s<ret>'\n" "$paste"
    printf "define-command -override echo-to-clipboard -params .. %%{ echo -to-shell-script '%s' -- %%arg{@} }" "$copy"
}

# https://zellij.dev/
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

provide-module zellij %{

# ensure we're running under zellij
evaluate-commands %sh{
    [ -z "${kak_opt_windowing_modules}" ] || [ -n "$ZELLIJ" ] || echo 'fail zellij not detected'
}

define-command -hidden -params 2.. zellij %{
    evaluate-commands %sh{
       zellij "$@" < /dev/null > /dev/null 2>&1 &
    }
}
define-command -hidden -params 1.. zellij-terminal-impl %{ evaluate-commands %sh{
   arg_count=0
   i=1
   while [ $i -lt $# ]; do
       a=${@:$i:1}
       if [ "${a:0:1}" = "-" ]; then
           if [ "${a:1:1}" = "d" -o "${a:1:1}" = "n" ]; then
               ((i+=2))
           else
               ((i+=1))
           fi
           arg_count=$((i-1))
       else
           arg_count=$((i-1))
           i=$#
       fi
   done
   echo zellij run ${@:1:$arg_count} -- $SHELL -i -c "'"${@:$((1+$arg_count))}"'"
}}
complete-command zellij-terminal-impl shell

define-command zellij-terminal-vertical -params 1.. -docstring '
zellij-terminal-vertical <program> [<arguments>]: create a new terminal as a zellij pane
The current pane is split into two, top and bottom
The program passed as argument will be executed in the new terminal' \
%{
    zellij-terminal-impl -d down %arg{@}
}
complete-command zellij-terminal-vertical shell

define-command zellij-terminal-horizontal -params 1.. -docstring '
zellij-terminal-horizontal <program> [<arguments>]: create a new terminal as a zellij pane
The current pane is split into two, left and right
The program passed as argument will be executed in the new terminal' \
%{
    zellij-terminal-impl -d right %arg{@}
}
complete-command zellij-terminal-horizontal shell

define-command zellij-terminal-window-edit -params .. -docstring '
zellij-terminal-window-edit <file>: create a new window to edit given file' \
%{
    zellij-terminal-impl -c kak -c %val{session} %arg{@}
}
complete-command zellij-terminal-window-edit file

define-command zellij-focus -params 0 -docstring '
zellij-focus: focus a panel' \
%{
    zellij action switch-mode pane
}

## The default behaviour for the `new` command is to open an horizontal pane in a zellij session
alias global focus zellij-focus
alias global terminal zellij-terminal-impl
alias global window-edit zellij-terminal-window-edit

}
evaluate-commands %sh{
    if [ -n "$ZELLIJ" ]; then
        printf 'require-module zellij'
    fi
}

